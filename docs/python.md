## Overview
The python 'interface' is only an extended UCI interface. Lots of FENparsing to and fro, and as a result it's slower than the pure python implmentaion I first built. 
Drop odonata binary into you working directory, or supply a path to Odonata.instance() on first call before anything else...





```python
def demo_3():
    b = Board.parse_fen("r1k5/8/8/2K5/8/8/8/R6R w - - 0 10")
    algo = Algo(depth = 6)
    bm = algo.search(b)
    print(f'''

    board as a FEN string 
    {b.to_fen()}    

    board as a grid 
    {b.grid}    

    best move
    {bm}

    max_depth: {algo.max_depth()}
    seldepth : {algo.seldepth()}
    nodes    : {algo.nodes()}
    nodes/sec: {algo.nps()}
    time (ms): {algo.time()}
    score    : {algo.centipawns()}
    mate in  : {algo.mate_in()}
    prin var : {" ".join(algo.pv())}  

    ''')

    # lets play out the pv
    for i, move in enumerate(algo.pv()):
        b = b.make_move(move)
        print(f"Move #{i+1}: {move}\nPosition\n{b.grid}\n")

```


```
Demo 3
======


board as a FEN string
r1k5/8/8/2K5/8/8/8/R6R w - - 0 10

board as a grid
r.k.....
........
........
..K.....
........
........
........
R......R

best move
a1a8

max_depth: 5
seldepth : 6
nodes    : 14349
nodes/sec: 1195000
time (ms): 11
score    : 0
mate in  : 3
prin var : a1a8 c8d7 h1e1 d7c7 e1e7


Move #1: a1a8
Position
R.k.....
........
........
..K.....
........
........
........
.......R

Move #2: c8d7
Position
R.......
...k....
........
..K.....
........
........
........
.......R

Move #3: h1e1
Position
R.......
...k....
........
..K.....
........
........
........
....R...

Move #4: d7c7
Position
R.......
..k.....
........
..K.....
........
........
........
....R...

Move #5: e1e7
Position
R.......
..k.R...
........
..K.....
........
........
........
........

```